{"version":3,"file":"static/chunks/1.js","sources":["webpack:///./src/articles/edge-with-courage-reasonml.md"],"sourcesContent":["export default \"---\\ntitle: The Edge, Wit, and Courage of ReasonML\\ndate: 2019-03-19T21:25:04.540Z\\nslug: edge-wit-courage-reasonml\\ndescription: Discover the features of Reason that make it so appealing to a JavaScript developer.\\ntags: reason,ocaml,javascript,fp\\nhero_image: steps.jpg\\n---\\n\\n![](/steps.jpg)\\n\\nReasonML has stolen my attention recently.\\n\\nIf I'm not at work or running about, I am probably digging into some ReasonML/OCaml repositories like an addict in the tenderloin.\\n\\nPerhaps I like it for the unparalleled incremental build speed.\\n\\nPerhaps I like it because its not too different from JavaScript yet it nets me a plethora of built-in advantages like type safety.\\n\\nPerhaps I like it because of my affinity for math in school, and the functional paradigm gives me a warm fuzzy feeling inside.\\n\\nThere are a few reasons, no pun intended, for my love of Reason. Just like a functional program wields function composition with immutable state to achieve its goal, Reason's composition of the best of OCaml and JavaScript make it a strong candidate for the future of programming.\\n\\n## The Edge of OCaml\\n\\nFor starters, Reason is basically a syntax upgrade to OCaml. Let me start by describing how that helps us.\\n\\n### Speed\\n\\nOCaml is a pretty damn fast language. It's incremental build times dwarf that of almost any other language. Since Reason is just a toolchain on top of OCaml, it maintains the many of the same characteristics of OCaml.\\n\\nFor instance take a look at this table from the docs of [fastpack](https://fastpack.sh), an alternative to Webpack or Parcel for bundling JavaScript applications.\\n\\n_~1100 modules / 5.3Mb / MB Pro 2017_\\n\\n|                  | Fastpack | Webpack | Parcel |\\n| ---------------- | -------- | ------- | ------ |\\n| initial build    | 0.811s   | 3.86s   | 11.07s |\\n| persistent cache | 0.208s   | N/A     | 1.39s  |\\n| watch mode       | 0.088s   | 0.226s  | 0.291s |\\n\\nFastpack is still rather new but these numbers are promising -- and the result implies we can made super-quick devtools for a vanilla JavaScript workflow.\\n\\n### Static Typing\\n\\nAnother thing Reason inherits from OCaml is a power, nearly impenetrable type system. The compiler does a solid job of making sure you exhaust all of your options in branching logic.\\n\\nIt also does away with silly errors like \\\"undefined is not a function\\\" or \\\"cannot read property 'x'\\\". The same could be said about adopting TypeScript or Flow, but they do not _force_ you to cover such cases.\\n\\n### ...with Great Inference\\n\\nIt's powerful type inference cleans up a lot of the verbosity associated with annotating functions and variables with types. The following function adds two integers. Not two floats or two strings, just two integers.\\n\\n```reason\\n  /* the type system knows that the arguments and the return value are ints here */\\n  let add = (a, b) => a + b;\\n```\\n\\nIf that example is too basic, then try this one. Note how I am not annotating the types in the function signatures:\\n\\n```reason\\n  type animal =\\n    | Dog\\n    | Cat\\n    | Octopus;\\n\\n  let animalToString = animal =>\\n    switch(animal) {\\n    | Dog => \\\"dog\\\"\\n    | Cat => \\\"cat\\\"\\n    | Octopus => \\\"octopus\\\"\\n    };\\n\\n  let getWelcomeMessage = (name, visits, animal) => {\\n    \\\"Hello \\\" ++\\n    name ++\\n    \\\", you've visited this website \\\" ++\\n    string_of_int(visits) ++\\n    \\\" times and your favorite animal is the \\\" ++\\n    animalToString(animal);\\n  };\\n```\\n\\nThe ReasonML/OCaml type system is capable of inferring based on our usage what the return types are, as well as each of the arguments. How neat is that?\\n\\n### Industry Proven\\n\\nOCaml is a proven language of academics and industries where safety and mission critical code is paramount. This was one of the reason's it was adopted as the base for ReasonML.\\n\\nAt Facebook, OCaml is used to build some of their important everyday tools, like [Flow](https://flow.org) and [Hack](https://hacklang.org). But they're also working on Reason, which in my opinion, is neat because Reason brings more joy than flow.\\n\\n## The Wit of JavaScript\\n\\nWith Reason comes a lighter, more JavaScript-like syntax. The first example I showed above would work just as well in regular JavaScript.\\n\\n### Syntax\\n\\nReason syntax is far easier to read and digest than that of OCaml, and most other functional languages for that matter.\\n\\n### Easy Build System\\n\\nIts massively more accessible to newcomers than OCaml in that you probably wont spend days trying to install your dependencies properly. When using BuckleScript its often just another npm install {package}.\\n\\n### JavaScript Interop\\n\\nIf you need training wheels when writing Reason, do not fear. You can use special directives to write JavaScript directly in your Reason code. Its not cheating, the language was designed this way to make migrating codebases easier.\\n\\n### NodeJS Too\\n\\nThe language that powers web applications can be used on the server with the help of NodeJS. The language being Reason of course. Since it transpiles to JavaScript, theres no reason you cannot simply write Reason which becomes server code.\\n\\nYou can write basically everything in your tech stack with JavaScript and in most cases it will be just fine. What motive would someone have to write Reason then, especially if they have built their likely profitable career on JavaScript?\\n\\n## The Courage of Reason\\n\\nOver the past few weeks, I've been exploring writing Native Reason code. I think some of the projects that are being developed show great courage in showing off the potential of ReasonML.\\n\\nWhile I certainly appreciate it's benefits on the frontend when transpiled to JavaScript, it would be super neat if I could write it on the server too.\\n\\nI want to communicate with databases, make blazing quick command line tools, and write super efficient servers, perhaps serving GraphQL.\\n\\nAnd I want to do it with the same language that I'm writing in for my web applications.\\n\\nCurrently, we can do this with JavaScript, but I think we can do better.\\n\\nBy further leveraging the OCaml ecosystem we can actually write incredibly robust servers and developer tools.\\n\\nThe [Esy](https://esy.sh) package manager allows us to install and build packages from npm or opam in a convenient package.json fashion without having to manually hack system dependencies.\\n\\nAs Esy further develops, Reason on the backend will become increasingly more accessible to developers looking to write stupidly fast native code.\\n\\nIf you're interested in what's already been made with Esy, check out the following projects:\\n\\n- [fnm](https://github.com/Schniz/fnm), an alternative to nvm for managing your NodeJS version. It's much faster than nvm.\\n- [fastpack](https://fastpack.sh/), a ridiculously fast JavaScript bundler\\n- [revery](https://www.outrunlabs.com/revery/), a desktop UI framework like electron, except without downloading a whole browser onto your users' computer.\\n\\nAnd there are more out there in the **Forests of Open Source**.\\n\\nThis certainly won't be my last post on this topic so stay tuned for more Reason evangelism on the horizon.\\n\";"],"mappings":";;;;;;;;;;AAAA;AAAA;;;;A","sourceRoot":""}