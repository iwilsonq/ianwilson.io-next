exports.ids = [3];
exports.modules = {

/***/ "./src/articles/intro-to-reasonml-variants.md":
/*!****************************************************!*\
  !*** ./src/articles/intro-to-reasonml-variants.md ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("---\ntitle: Intro to ReasonML Variants\ndate: 2019-03-02T21:25:04.540Z\nslug: intro-to-reasonml-variants\ndescription: Learn to wield ReasonML variants to create better, typesafe web applications\ntags: reason,javascript,webdev,functional\n---\n\nReasonML is a super fast, expressive, and functional programming language. Currently, it can be compiled to optimized JavaScript for the web, WebGL/OpenGL for graphics rendering, or even native bytecode.\n\nOne of my favorite features of Reason are variant data types. These types allow us to handle enums in a sane way, forcing us to handle all possibilities for a particular scenario. We can define a variant type like this:\n\n```reason\ntype color =\n  | Red\n  | Blue\n  | White\n  | Black\n  | Grey;\n```\n\nWe see that the type `color` can be represented as this enumeration of different colors. Not too complicated, but not too enlightening either. In JavaScript, we could handle this with an object mapping:\n\n```javascript\nconst COLORS = {\n  RED: 'red',\n  BLUE: 'blue',\n  WHITE: 'white',\n  BLACK: 'black',\n  GREY: 'grey',\n};\n```\n\nI used maps like this all the time in my JavaScript projects, they help a ton when your goal is to keep constants defined in the same place. If you need to update, add, or remove a field, you only need to do so in one location.\n\nIf this were the whole story, I would probably decide that a compiled-to-js programming language like Reason is not worth the effort involved when I could just add TypeScript support. After all, so far it has only saved us a tiny amount of code.\n\nLet's take a look at an example to see how Reason would help us where ordinary JavaScript falls short.\n\n```javascript\nfunction getMonthlyPriceForCarColor(color) {\n  switch (color) {\n    case COLORS.RED:\n      return 28;\n    case COLORS.BLUE:\n      return 24;\n    case COLORS.WHITE:\n      return 20;\n  }\n}\n```\n\nThis function takes a color (from our convenient colors lookup-map) and returns to us the additional monthly price of getting a Tesla Model S. In other words, getting a red Tesla costs more because it is the best color.\n\nOne other thing you might notice is that I did not provide a default case, and as an imperfect programmer, I neglected some of the other colors. JavaScript will not yell at me for this on its own, so I will probably have to find out the hard way that I forgot some of the other cases.\n\nHopefully QA will catch this bug before my code lands in production. But even if they're really thorough, I'd still have to make changes and push/review more code. Wouldn't it be nice if our typechecker could alert us on the fly?\n\nThe same function in Reason looks like this:\n\n```reason\nlet getMonthlyPriceForCarColor = color =>\n  switch(color) {\n    | Red => 28\n    | Blue => 24\n    | White => 20\n  };\n```\n\nFirst of all there's less code, which is great, but beside the point. In practice, this function will actually have red squiggly underlines, alerting us that our switch is not exhaustive - it does not cover all of the possibilities or our `color` variant.\n\nThe error message is actually quite helpful when this happens.\n\n![Error: Non exhaustive switch statement](/images/non-exhaustive.png)\n\nFixing this issue simply requires that you cover the other possibilities.\n\n```reason\nlet getMonthlyPriceForCarColor = color =>\n  switch(color) {\n    | Red => 28\n    | Blue => 24\n    | White => 20\n    | Black => 0\n    | Grey => 0\n  };\n```\n\nReason wont let us compile our code if we don't have a case for each possibility in this function. This is a sampling of the incredibly powerful typesystem we have with Reason.\n\n## Variants as Constructors\n\nAs I've demonstrated so far, variants can be used as enumerations, but they exhibit a power that takes enumeration to a whole new level. Variants can be used as generic constructors that take arguments, allowing developers to further customize applications for their use case.\n\nFor example, we can adjust our price (arbitraily) based on the shade of grey or even go as far as to specify a totally arbitrary color somewhere in the RGB scale.\n\nUpdating our color type to the following:\n\n```reason\ntype color =\n  | Red\n  | Blue\n  | White\n  | Black\n  | Grey(float)\n  | Rgb(int, int, int);\n```\n\nNow when we run our function, we can let the customer to pick whatever color they want. To keep make the pricing more reasonable with our already hardcoded values, we'll allow grey to range from $0 to $20. depending on whatever number given between 0.0 and 1.0.\n\nThe `Rgb` constructor will be the most expensive since we have to create new paint in order to satisfy that requirement. The higher the values of red, blue, and green color, the closer to \\$36 it will be.\n\n```reason\nlet getMonthlyPriceForCarColor = color =>\n  switch(color) {\n    | Red => 28\n    | Blue => 24\n    | White => 20\n    | Black => 0\n    | Grey(pct) => int_of_float(pct *. 20.0)\n    | Rgb(red, green, blue) => {\n      /* completely random calculation. Tesla probably does not do this */\n      let sum = red + green + blue;\n      if (sum > 500) {\n        36\n      } else {\n        32\n      }\n    }\n  };\n\nJs.log(getMonthlyPriceForCarColor(Red));                /* 28 */\nJs.log(getMonthlyPriceForCarColor(Grey(0.64)));         /* 12 */\nJs.log(getMonthlyPriceForCarColor(Rgb(150, 210, 67)));  /* 32 */\nJs.log(getMonthlyPriceForCarColor(Rgb(150, 210, 167))); /* 36 */\n```\n\nThis is pretty neat huh? This example displays the expressive power of a robust type-safe language like Reason.\n\nWhen we introduce constructor arguments like this, we no longer have an ordinary switch statement that you can find in most programming languages. We call this _pattern matching_ in Reason.\n\nIn conjuction with data structures like variants, tuples, and lists, pattern matching creates a readable and concise flow of logic.\n\n## Refactor with confidence\n\nThe only thing I have yet to do to make this example stronger, is validate the constructor inputs. So to send off this post with a bang, I am going to make some helper functions.\n\n```reason\nlet validatePercentage = pct =>\n  restrictRangef(pct, 0.0, 1.0);\n\nlet validateRgb = (red, blue, green) => {\n  let red = restrictRange(red, 0, 255);\n  let green = restrictRange(green, 0, 255);\n  let blue = restrictRange(blue, 0, 255);\n  (red, blue, green);\n};\n```\n\nThese functions validate the required input to the extend that they cut off the values if they are too low or too high. Here are their corresponding `restrictRange` functions.\n\n```reason\nlet restrictRange = (number, min, max) =>\n  if (number > max) {\n    max;\n  } else if (number < min) {\n    min;\n  } else {\n    number;\n  };\n\nlet restrictRangef = (number, min, max) =>\n  if (number > max) {\n    max;\n  } else if (number < min) {\n    min;\n  } else {\n    number;\n  };\n```\n\nOne last thing to note is that we must have separate `restrictRange` functions for `int` and `float` types. By convention, when we have functions that take ints, their float variation will have the same name but with an \"f\" at the end.\n\nA little extra code here is a small price to pay here when we have superior type coverage.\n\nFinally I can update our `getMonthlyPriceForCarColor` function with our new helpers:\n\n```reason\nlet getMonthlyPriceForCarColor = color =>\n  switch (color) {\n  | Red => 28\n  | Blue => 24\n  | White => 20\n  | Black => 0\n  | Grey(pct) => int_of_float(validatePercentage(pct) *. 20.0)\n  | Rgb(red, green, blue) => {\n      let (r, g, b) = validateRgb(red, green, blue);\n      let sum = r + g + b;\n      if (sum > 500) {\n        36\n      } else {\n        32\n      };\n    }\n  };\n```\n\n# And thats a wrap\n\nWe've taken a look at variants and how we can use them with constructor arguments through pattern matching. This is a super powerful feature that you won't find in just any modern programming language.\n\nWhen you build an application with complete type safety, you begin to reap the advantages as the size of your project grows and you begin to make refactors. Knowing that your code compiles increases your confidence that you wont break critical or even basic features in production.\n");

/***/ })

};;
//# sourceMappingURL=3.js.map